<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xGo 开发博客</title>
  
  <subtitle>xGo 开发博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://xgoteam.com/"/>
  <updated>2019-04-17T02:58:55.399Z</updated>
  <id>https://xgoteam.com/</id>
  
  <author>
    <name>xGo Team</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python机器学习入门之数据预处理</title>
    <link href="https://xgoteam.com/2019/04/16/python%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86/"/>
    <id>https://xgoteam.com/2019/04/16/python机器学习入门之数据预处理/</id>
    <published>2019-04-16T17:18:19.000Z</published>
    <updated>2019-04-17T02:58:55.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="python机器学习入门之数据预处理"><a href="#python机器学习入门之数据预处理" class="headerlink" title="python机器学习入门之数据预处理"></a>python机器学习入门之数据预处理</h2><hr><h3 id="机器学习的流程"><a href="#机器学习的流程" class="headerlink" title="机器学习的流程"></a>机器学习的流程</h3><h4 id="数据处理阶段"><a href="#数据处理阶段" class="headerlink" title="数据处理阶段"></a>数据处理阶段</h4><ol><li>数据采集   </li><li>数据清洗  </li></ol><h4 id="训练模型阶段"><a href="#训练模型阶段" class="headerlink" title="训练模型阶段"></a>训练模型阶段</h4><ol start="3"><li>数据预处理  </li><li>选择模型（算法）  </li><li>验证模型  </li><li>训练模型  </li><li>测试模型（模型不合适 -&gt; 选择模型 或 训练模型）  </li></ol><h4 id="实际业务场景"><a href="#实际业务场景" class="headerlink" title="实际业务场景"></a>实际业务场景</h4><ol start="8"><li>使用模型  </li><li>维护和升级  </li></ol><h3 id="为什么使用-Python-进行机器学习"><a href="#为什么使用-Python-进行机器学习" class="headerlink" title="为什么使用 Python 进行机器学习"></a>为什么使用 Python 进行机器学习</h3><h4 id="Python-更专注于解决现实问题"><a href="#Python-更专注于解决现实问题" class="headerlink" title="Python 更专注于解决现实问题"></a>Python 更专注于解决现实问题</h4><p>Python 提高了大量数据处理（ NumPy、Pandas ）、机器学习（ Scikit_learn ）及深度学习（ TensorFlow、PyTorch 等）相关的依赖库，使用者可以更加专注算法的实现而不用从头开始实现基本算法。</p><h4 id="Python-很慢？"><a href="#Python-很慢？" class="headerlink" title="Python 很慢？"></a>Python 很慢？</h4><p>Python 确实很慢，但是可以把计算量大的部分交由其他更高效（但更难使用）的语言（如 C 和 C++ ）进行处理。实际运用中，几乎所有程序都会使用 NumPy 去完成计算，所有没有必要担心程序的运行速度。<br>NumPy 与原生 Python 的比较：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">from datetime import datetime</span><br><span class="line"><span class="comment"># 原生python</span></span><br><span class="line">n = 100000</span><br><span class="line">start = datetime.now()</span><br><span class="line">A, B = [], []</span><br><span class="line">for i in range(n):</span><br><span class="line">    A.append(i ** 2)</span><br><span class="line">    B.append(i ** 3)</span><br><span class="line">C = []</span><br><span class="line">for a, b in zip(A, B):</span><br><span class="line">    C.append(a + b)</span><br><span class="line">t1 = (datetime.now() - start).microseconds</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy</span></span><br><span class="line">start = datetime.now()</span><br><span class="line">A, B = np.arange(n) ** 2, np.arange(n) ** 3</span><br><span class="line">C = A + B</span><br><span class="line">t2 = (datetime.now() - start).microseconds</span><br><span class="line"></span><br><span class="line">print(f'&#123;t1/t2&#125;倍')</span><br><span class="line"><span class="comment"># 大约是20倍</span></span><br></pre></td></tr></table></figure><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><h4 id="均值移除（列处理）"><a href="#均值移除（列处理）" class="headerlink" title="均值移除（列处理）"></a>均值移除（列处理）</h4><p>通过调整令样本矩阵中每一列（特征）的平均值为 0 ，标准差为 1 。  这样一来，所有特征对最终模型的预测结果都有接近一致的贡献，模型对每个特征的倾向性更加均衡。  </p><p>假设样本为 $[a, b, c]$<br>均值：$m=\frac{(a+b+c)}{3}$<br>标准差：$s=\sqrt{\frac{(a-m)^2+(b-m)^2+(c-m)^2}{3}}$<br>均值 -&gt; 0：$a^{‘}=a-m$ , $b^{‘}=b-m$ , $c^{‘}=c-m$<br>标准差 -&gt; 1：$a^{“}=\frac{a^{‘}}{s}$ , $b^{“}=\frac{b^{‘}}{s}$ , $c^{“}=\frac{c^{‘}}{s}$<br>得到标准样本 $[a^{“}, b^{“}, c^{“}]$</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">raw_samples = np.array([</span><br><span class="line">    [3, -1.5,  2,   -5.4],</span><br><span class="line">    [0,  4,   -0.3,  2.1],</span><br><span class="line">    [1,  3.3, -1.9, -4.3]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy</span></span><br><span class="line"><span class="comment"># 均值移除</span></span><br><span class="line">std_samples = raw_samples.copy()</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> std_samples.T:</span><br><span class="line">    col_mean = col.mean()</span><br><span class="line">    col_std = col.std()</span><br><span class="line">    col -= col_mean</span><br><span class="line">    col /= col_std</span><br><span class="line"><span class="builtin-name">print</span>(std_samples)</span><br><span class="line"><span class="builtin-name">print</span>(std_samples.mean(<span class="attribute">axis</span>=0))</span><br><span class="line"><span class="builtin-name">print</span>(std_samples.std(<span class="attribute">axis</span>=0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn</span></span><br><span class="line"><span class="comment"># 均值移除</span></span><br><span class="line">import sklearn.preprocessing as sp</span><br><span class="line">std_samples = sp.scale(raw_samples)</span><br><span class="line"><span class="builtin-name">print</span>(std_samples)</span><br><span class="line"><span class="builtin-name">print</span>(std_samples.mean(<span class="attribute">axis</span>=0))</span><br><span class="line"><span class="builtin-name">print</span>(std_samples.std(<span class="attribute">axis</span>=0))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># std_samples</span><br><span class="line">[[ <span class="number">1.33630621</span> <span class="number">-1.40451644</span>  <span class="number">1.29110641</span> <span class="number">-0.86687558</span>]</span><br><span class="line"> [<span class="number">-1.06904497</span>  <span class="number">0.84543708</span> <span class="number">-0.14577008</span>  <span class="number">1.40111286</span>]</span><br><span class="line"> [<span class="number">-0.26726124</span>  <span class="number">0.55907936</span> <span class="number">-1.14533633</span> <span class="number">-0.53423728</span>]]</span><br><span class="line"></span><br><span class="line"># std_samples.mean(axis=<span class="number">0</span>)</span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"></span><br><span class="line"># std_samples.std(axis=<span class="number">0</span>)</span><br><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure><h4 id="范围缩放（列处理）"><a href="#范围缩放（列处理）" class="headerlink" title="范围缩放（列处理）"></a>范围缩放（列处理）</h4><p>将样本矩阵每一列的元素经过线性变换，使得所有列的元素都处在同样的范围区间内。<br>样本矩阵中每一列的最大值和最小值为某个给定的值 ([0, 1]) ，其他元素线性变换。</p><p>变换原理： $y = kx + b$<br>最小值：$y_{min} = kx_{min} + b$<br>最大值：$y_{max} = kx_{max} + b$<br>矩阵运算： $ \begin{vmatrix} x_{min} &amp; 1 \ x_{max} &amp; 1 \ \end{vmatrix} * \begin{vmatrix} k \ b \ \end{vmatrix} = \begin{vmatrix} y_{min} \ y_{max} \ \end{vmatrix}$</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">raw_samples = np.array([</span><br><span class="line">    [3, -1.5,  2,   -5.4],</span><br><span class="line">    [0,  4,   -0.3,  2.1],</span><br><span class="line">    [1,  3.3, -1.9, -4.3]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最小值,最大值</span></span><br><span class="line"><span class="builtin-name">print</span>(raw_samples.min(<span class="attribute">axis</span>=0)) # [0. -1.5 -1.9 -5.4]</span><br><span class="line"><span class="builtin-name">print</span>(raw_samples.max(<span class="attribute">axis</span>=0)) # [3.  4.   2.   2.1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy</span></span><br><span class="line"><span class="comment"># 范围缩放</span></span><br><span class="line">mms_samples = raw_samples.copy()</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> mms_samples.T:</span><br><span class="line">    col -= col.min()</span><br><span class="line">    col /= col.max()</span><br><span class="line"><span class="builtin-name">print</span>(mms_samples)</span><br><span class="line"><span class="builtin-name">print</span>(mms_samples.min(<span class="attribute">axis</span>=0))</span><br><span class="line"><span class="builtin-name">print</span>(mms_samples.max(<span class="attribute">axis</span>=0))</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn</span></span><br><span class="line"><span class="comment"># 范围缩放</span></span><br><span class="line">import sklearn.preprocessing as sp</span><br><span class="line">mms = sp.MinMaxScaler(feature_range=(0, 1))  # 缩放器对象</span><br><span class="line">mms_samples = mms.fit_transform(raw_samples)</span><br><span class="line"><span class="builtin-name">print</span>(mms_samples)</span><br><span class="line"><span class="builtin-name">print</span>(mms_samples.min(<span class="attribute">axis</span>=0))</span><br><span class="line"><span class="builtin-name">print</span>(mms_samples.max(<span class="attribute">axis</span>=0))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># mms_samples</span><br><span class="line">[[<span class="number">1.</span>         <span class="number">0.</span>         <span class="number">1.</span>         <span class="number">0.</span>        ]</span><br><span class="line"> [<span class="number">0.</span>         <span class="number">1.</span>         <span class="number">0.41025641</span> <span class="number">1.</span>        ]</span><br><span class="line"> [<span class="number">0.33333333</span> <span class="number">0.87272727</span> <span class="number">0.</span>         <span class="number">0.14666667</span>]]</span><br><span class="line"></span><br><span class="line"># mms_samples.min(axis=<span class="number">0</span>)</span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"></span><br><span class="line"># mms_samples.max(axis=<span class="number">0</span>)</span><br><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure><h4 id="归一化（行处理）"><a href="#归一化（行处理）" class="headerlink" title="归一化（行处理）"></a>归一化（行处理）</h4><p>用每个样本各个特征值除以该样本所有特征值绝对值之和，使得的处理后的样本矩阵中各行所有元素的绝对值之和为 1 。</p><table><thead><tr><th>-</th><th>Python</th><th>C++</th><th>Java</th><th>PHP</th><th>SUM</th></tr></thead><tbody><tr><td>处理前</td><td>20</td><td>30</td><td>40</td><td>10</td><td>100</td></tr><tr><td>处理后</td><td>0.2</td><td>0.3</td><td>0.4</td><td>0.1</td><td>1</td></tr></tbody></table><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">raw_samples = np.array([</span><br><span class="line">    [3, -1.5,  2,   -5.4],</span><br><span class="line">    [0,  4,   -0.3,  2.1],</span><br><span class="line">    [1,  3.3, -1.9, -4.3]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy</span></span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">nor_samples = raw_samples.copy()</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> nor_samples:</span><br><span class="line">    row /= np.abs(row).sum()</span><br><span class="line"><span class="builtin-name">print</span>(nor_samples)</span><br><span class="line"><span class="builtin-name">print</span>(abs(nor_samples).sum(<span class="attribute">axis</span>=1))</span><br><span class="line"></span><br><span class="line"><span class="comment"># sklearn</span></span><br><span class="line"><span class="comment"># 归一化</span></span><br><span class="line">import sklearn.preprocessing as sp</span><br><span class="line">nor_samples = sp.normalize(raw_samples, <span class="attribute">norm</span>=<span class="string">'l1'</span>)</span><br><span class="line"><span class="comment"># norm='ln' 为 ln范数，表示列元素的绝对值的n次方之和</span></span><br><span class="line"><span class="builtin-name">print</span>(nor_samples)</span><br><span class="line"><span class="builtin-name">print</span>(abs(nor_samples).sum(<span class="attribute">axis</span>=1))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># nor_samples</span><br><span class="line">[[<span class="number">0.25210084</span> <span class="number">-0.12605042</span>  <span class="number">0.16806723</span> <span class="number">-0.45378151</span>]</span><br><span class="line"> [<span class="number">0.</span>          <span class="number">0.625</span>      <span class="number">-0.046875</span>    <span class="number">0.328125</span>  ]</span><br><span class="line"> [<span class="number">0.0952381</span>   <span class="number">0.31428571</span> <span class="number">-0.18095238</span> <span class="number">-0.40952381</span>]]</span><br><span class="line"></span><br><span class="line"># abs(nor_samples).sum(axis=<span class="number">1</span>)</span><br><span class="line">[<span class="number">1.</span> <span class="number">1.</span> <span class="number">1.</span>]</span><br></pre></td></tr></table></figure><h4 id="二值化"><a href="#二值化" class="headerlink" title="二值化"></a>二值化</h4><p>根据事先给定阈值，将样本矩阵中高于阈值的元素设置为 1 ，否则设置为 0 ，得到一个完全由 1 和 0 组成的二值矩阵。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">raw_samples = np.array([</span><br><span class="line">    [<span class="number">3</span>, <span class="number">-1.5</span>,  <span class="number">2</span>,   <span class="number">-5.4</span>],</span><br><span class="line">    [<span class="number">0</span>,  <span class="number">4</span>,   <span class="number">-0.3</span>,  <span class="number">2.1</span>],</span><br><span class="line">    [<span class="number">1</span>,  <span class="number">3.3</span>, <span class="number">-1.9</span>, <span class="number">-4.3</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">bin_samples = raw_samples.copy()</span><br><span class="line"></span><br><span class="line"># numpy</span><br><span class="line"># 二值化 -&gt; 掩码</span><br><span class="line"># 阈值为<span class="number">1.4</span></span><br><span class="line">bin_samples[bin_samples &lt;= <span class="number">1.4</span>] = <span class="number">0</span></span><br><span class="line">bin_samples[bin_samples &gt; <span class="number">1.4</span>] = <span class="number">1</span></span><br><span class="line">print(bin_samples)</span><br><span class="line"></span><br><span class="line"># sklearn</span><br><span class="line"># 二值化</span><br><span class="line">import sklearn.preprocessing as sp</span><br><span class="line">bin = sp.Binarizer(threshold=<span class="number">1.4</span>)  # 二值化对象，阈值为<span class="number">1.4</span></span><br><span class="line">bin_samples = bin.transform(raw_samples)</span><br><span class="line">print(bin_samples)</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># bin_samples</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure><h4 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h4><p>用一个只包含一个 1 和若干个 0 的序列来表达每个特征值的编码方式，借此既保留了样本矩阵的所有细节，同时又得到一个只含有 1 和 0 的稀疏矩阵，既可以提高模型的容错性，同时还能节省内存空间。</p><table><thead><tr><th>处理前</th><th>a</th><th>b</th><th>c</th><th>处理后</th><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>A</td><td>1</td><td>2</td><td>0</td><td>A</td><td>10</td><td>100</td><td>1000</td></tr><tr><td>B</td><td>4</td><td>5</td><td>3</td><td>B</td><td>01</td><td>010</td><td>0100</td></tr><tr><td>C</td><td>1</td><td>8</td><td>6</td><td>C</td><td>10</td><td>001</td><td>0010</td></tr><tr><td>D</td><td>4</td><td>2</td><td>9</td><td>D</td><td>01</td><td>100</td><td>0000</td></tr></tbody></table><p>映射规则</p><table><thead><tr><th>a</th><th>b</th><th>c  </th></tr></thead><tbody><tr><td>1-&gt; 10</td><td>2-&gt; 100</td><td>0-&gt; 1000</td></tr><tr><td>4-&gt; 01</td><td>5-&gt; 010</td><td>3-&gt; 0100  </td></tr><tr><td>-</td><td>8-&gt; 001</td><td>6-&gt; 0010</td></tr><tr><td>-</td><td>-</td><td>9-&gt; 0001</td></tr></tbody></table><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">import numpy <span class="keyword">as</span> np</span><br><span class="line">raw_samples = np.array([</span><br><span class="line">    [<span class="meta">1, 2, 0</span>],</span><br><span class="line">    [<span class="meta">4, 5, 3</span>],</span><br><span class="line">    [<span class="meta">1, 8, 6</span>],</span><br><span class="line">    [<span class="meta">4, 2, 9</span>]</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="meta"># 建立编码字典列表</span></span><br><span class="line">code_tables = []</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> raw_samples.T:</span><br><span class="line">    <span class="meta"># 针对一列的编码字典</span></span><br><span class="line">    code_table = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> col:</span><br><span class="line">        code_table[val] = None</span><br><span class="line">    code_tables.append(code_table)</span><br><span class="line"></span><br><span class="line"><span class="meta"># 为编码字典列表中每个编码字典添加值</span></span><br><span class="line"><span class="keyword">for</span> code_table <span class="keyword">in</span> code_tables:</span><br><span class="line">    size = len(code_table)</span><br><span class="line">    <span class="keyword">for</span> one, <span class="function">key <span class="keyword">in</span> <span class="title">enumerate</span>(<span class="params">sorted(code_table.keys(</span>))):</span></span><br><span class="line"><span class="function">        code_table[key] </span>= np.zeros(shape=size, dtype=<span class="keyword">int</span>)</span><br><span class="line">        code_table[key][one] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># 根据编码字典表对原始样本矩阵做独热编码</span></span><br><span class="line">ohe_samples = []</span><br><span class="line"><span class="keyword">for</span> raw_sample <span class="keyword">in</span> raw_samples:</span><br><span class="line">    ohe_sample = np.array([], dtype=<span class="keyword">int</span>)</span><br><span class="line">    <span class="meta"># i: 原始样本的列数, key: 编码字典中的编码值</span></span><br><span class="line">    <span class="keyword">for</span> i, <span class="function">key <span class="keyword">in</span> <span class="title">enumerate</span>(<span class="params">raw_sample</span>):</span></span><br><span class="line"><span class="function">        ohe_sample </span>= np.hstack((ohe_sample, code_tables[i][key]))</span><br><span class="line">    ohe_samples.append(ohe_sample)</span><br><span class="line"><span class="meta"># 编码完成</span></span><br><span class="line">ohe_samples = np.array(ohe_samples)</span><br><span class="line">print(ohe_samples)</span><br><span class="line"></span><br><span class="line"><span class="meta"># sklearn</span></span><br><span class="line"><span class="meta"># 独热编码</span></span><br><span class="line">import sklearn.preprocessing <span class="keyword">as</span> sp</span><br><span class="line">ohe = sp.OneHotEncoder(sparse=False, dtype=<span class="keyword">int</span>)  <span class="meta"># 独热编码器对象</span></span><br><span class="line">ohe_samples = ohe.fit_transform(raw_samples)</span><br><span class="line">print(ohe_samples)</span><br><span class="line"><span class="meta"># spares = False, 记录0和1,输出原数组</span></span><br><span class="line">[<span class="meta">[1 0 1 0 0 1 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 1 0 1 0 0 1 0 0</span>]</span><br><span class="line"> [<span class="meta">1 0 0 0 1 0 0 1 0</span>]</span><br><span class="line"> [<span class="meta">0 1 1 0 0 0 0 0 1</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta"># sparse = True, 只记录1的索引,使用内存空间较少</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">2</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">0</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">6</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">7</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">0</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">8</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)        <span class="number">1</span></span><br><span class="line">(<span class="number">3</span>, <span class="number">1</span>)        <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="标签编码"><a href="#标签编码" class="headerlink" title="标签编码"></a>标签编码</h4><p>标签编码即是将文本形式的特征值转换为数值形式的特征值，其编码数值源于标签字符串的字典排序，与标签本身的含义无关。</p><table><thead><tr><th>语言（文本形式）</th><th>编码（数值形式）</th></tr></thead><tbody><tr><td>C</td><td>0</td></tr><tr><td>Java</td><td>1</td></tr><tr><td>PHP</td><td>2</td></tr><tr><td>Python</td><td>3</td></tr></tbody></table><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> sklearn.preprocessing <span class="keyword">as</span> sp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始样本</span></span><br><span class="line">raw_samples = np.array(</span><br><span class="line">    [<span class="string">'C'</span>, <span class="string">'Java'</span>, <span class="string">'C'</span>, <span class="string">'Python'</span>,<span class="string">'Java'</span>, <span class="string">'PHP'</span>, <span class="string">'Python'</span>, <span class="string">'PHP'</span>]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签编码器，编码时会记录标签和编码的映射，用于反查</span></span><br><span class="line">lbe = sp.LabelEncoder() </span><br><span class="line"></span><br><span class="line"><span class="comment"># 标签编码</span></span><br><span class="line">lbe_samples = lbe.fit_transform(raw_samples)</span><br><span class="line"><span class="built_in">print</span>(lbe_samples)</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反查</span></span><br><span class="line">raw_samples = lbe.inverse_transform(lbe_samples)</span><br><span class="line"><span class="built_in">print</span>(raw_samples)</span><br><span class="line">[<span class="string">'C'</span> <span class="string">'Java'</span> <span class="string">'C'</span> <span class="string">'Python'</span> <span class="string">'Java'</span> <span class="string">'PHP'</span> <span class="string">'Python'</span> <span class="string">'PHP'</span>]</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据预处理是机器学习训练模型阶段的起点。通过数据预处理，我们可以得到理想的用于训练和测试模型的数据集，之后就可以开始训练算法模型了。<br>希望这篇文章对于大家入门机器学习能有一定的帮助！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;python机器学习入门之数据预处理&quot;&gt;&lt;a href=&quot;#python机器学习入门之数据预处理&quot; class=&quot;headerlink&quot; title=&quot;python机器学习入门之数据预处理&quot;&gt;&lt;/a&gt;python机器学习入门之数据预处理&lt;/h2&gt;&lt;hr&gt;
&lt;h3 
      
    
    </summary>
    
      <category term="机器学习" scheme="https://xgoteam.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="https://xgoteam.com/tags/python/"/>
    
      <category term="机器学习" scheme="https://xgoteam.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="数据分析" scheme="https://xgoteam.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Firebase云消息传递实践</title>
    <link href="https://xgoteam.com/2019/04/01/Firebase%20%E4%BA%91%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%AE%9E%E8%B7%B5/"/>
    <id>https://xgoteam.com/2019/04/01/Firebase 云消息传递实践/</id>
    <published>2019-04-01T10:29:20.000Z</published>
    <updated>2019-04-17T02:58:55.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cloud-messaging简介"><a href="#cloud-messaging简介" class="headerlink" title="cloud-messaging简介"></a>cloud-messaging简介</h3><p>cloud-messaging是google提供的跨平台消息传递解决方案,功能类似国内的<strong><code>极光推送</code></strong></p><h3 id="cloud-messaging功能"><a href="#cloud-messaging功能" class="headerlink" title="cloud-messaging功能"></a>cloud-messaging功能</h3><ol><li>从我们的应用服务器发送通知消息(用于手机通知弹窗)或数据消息(app内处理的)</li><li>从客户端(ios,android,web)将消息发送到我们的应用服务器</li></ol><h3 id="cloud-messaging工作原理"><a href="#cloud-messaging工作原理" class="headerlink" title="cloud-messaging工作原理"></a>cloud-messaging工作原理</h3><ol><li>我们服务器和fcm通讯有两种协议,一种是http协议,一种是<a href="https://www.ibm.com/developerworks/cn/xml/x-xmppintro/index.html" target="_blank" rel="noopener">xmpp协议</a><br><img src="../images/cloud-messaging.png" alt="工作原理"><ol start="2"><li>我们如何识别客户端呢,ios或android需要在谷歌的服务器Fcm(Firebase Cloud Messaging)注册一个令牌(token),然后把这个令牌传送到服务器,我们服务器就可以通过这个令牌给对应的客户端发送消息了,注意以下三种情况注册令牌会发生改变,改变后请把这个注册重新发送到我们服务器:<ol><li>应用在新设备上恢复</li><li>用户卸载/重新安装应用</li><li>用户清除用户数据</li></ol></li></ol></li></ol><h3 id="cloud-messaging使用注意"><a href="#cloud-messaging使用注意" class="headerlink" title="cloud-messaging使用注意"></a>cloud-messaging使用注意</h3><ol><li>FCM 不保证传递顺序</li><li>接到 FCM XMPP 服务器的速率限制为每个项目每分钟 400 次连接</li><li>向单一设备<code>发送</code>最多 240 条消息/分钟和 5000 条消息/小时</li><li>每个<code>项目</code>的<code>上行消息</code>限制为 15000 条/分钟</li><li>将每台<code>设备</code>的<code>上行消息</code>限制为 1000 条/分钟</li><li>主题订阅添加/移除率限制为每个项目 3000 QPS</li><li>数据消息里面的键值只支持字符串</li></ol><h3 id="cloud-messaging使用-php"><a href="#cloud-messaging使用-php" class="headerlink" title="cloud-messaging使用(php)"></a>cloud-messaging使用(php)</h3><p>我们上行使用了XMPP协议,下行使用了http协议<br>为了简化开发我们使用了网上的<a href="https://github.com/kreait/firebase-php/tree/dd34c653997473e3ef2c2d1eb648edd44cc6c2f0" target="_blank" rel="noopener">SDK</a>和<a href="https://firebase-php.readthedocs.io/en/stable/cloud-messaging.html#" target="_blank" rel="noopener">SDK使用文档</a>,这个SDK目前只支持http协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;cloud-messaging简介&quot;&gt;&lt;a href=&quot;#cloud-messaging简介&quot; class=&quot;headerlink&quot; title=&quot;cloud-messaging简介&quot;&gt;&lt;/a&gt;cloud-messaging简介&lt;/h3&gt;&lt;p&gt;cloud-mess
      
    
    </summary>
    
      <category term="Firebase" scheme="https://xgoteam.com/categories/Firebase/"/>
    
    
      <category term="Firbase" scheme="https://xgoteam.com/tags/Firbase/"/>
    
  </entry>
  
  <entry>
    <title>Git 基础总结</title>
    <link href="https://xgoteam.com/2019/03/31/Git%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>https://xgoteam.com/2019/03/31/Git基础总结/</id>
    <published>2019-03-31T20:04:20.000Z</published>
    <updated>2019-04-17T02:58:55.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="菜鸟都知道-Git？"><a href="#菜鸟都知道-Git？" class="headerlink" title="菜鸟都知道 Git？"></a>菜鸟都知道 Git？</h3><p>Git 是一个分布式版本管理系统，修改一次代码并提交，就会产生一个版本，这是 Git 最基本的功能。</p><p>Git 还是多人开发时的重要版本管理工具，成员写好模块只需要推送简单的进行提交并 push 一下，其他成员就可以通过服务器获取到最新的代码。</p><h3 id="git-的特点"><a href="#git-的特点" class="headerlink" title="git 的特点"></a>git 的特点</h3><ul><li>方便多人协同开发</li><li>分布式，每一个副本都保留完成的仓库信息</li><li>速度快，除提取和推送外基本都是本地操作</li><li>方便版本控制</li></ul><h3 id="git-构成"><a href="#git-构成" class="headerlink" title="git 构成"></a>git 构成</h3><p>工作区：就是你在电脑里能看到的目录。<br>暂存区：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）<br>版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><h3 id="git-本地仓库操作"><a href="#git-本地仓库操作" class="headerlink" title="git 本地仓库操作"></a>git 本地仓库操作</h3><ul><li>git init //将所在文件夹初始化为 Git 仓库</li><li>git status //查看目前本地状态</li><li>git add .  //添加了所有修改过的文件到暂存区（代码颜色会红色变绿色）</li><li>git add path/to/file //添加指定文件到暂存区</li><li>git commit -m “说明” //将暂存区的文件添加到本地仓库。</li><li>git config user.name “哈哈哈” //设置本仓库的用户名</li><li>git config user.email “<a href="mailto:xgo_great.guo@xgo.one" target="_blank" rel="noopener">xgo_great.guo@xgo.one</a>“ //设置本仓库的 email</li><li>git commit -am “版本描述” //添加所有文件到暂存区并提交</li><li>git reflog //查看所有操作记录</li></ul><h3 id="git-版本回退"><a href="#git-版本回退" class="headerlink" title="git 版本回退"></a>git 版本回退</h3><ul><li>git log //查看提交日志</li><li>git reset –hard 版本号 //回退到指定版本号</li><li>git reset –hard HEAD^ //回退到上一个版本（注意！！！如果 HEAD 为合并产生的提交，要留意第一父提交和第二父提交问题，详见 <a href="https://imciel.com/2016/09/09/git-parent/）" target="_blank" rel="noopener">https://imciel.com/2016/09/09/git-parent/）</a></li></ul><h3 id="git-版本对比"><a href="#git-版本对比" class="headerlink" title="git 版本对比"></a>git 版本对比</h3><ul><li>git diff HEAD – login.py //对比版本库与工作区中某文件的修改</li><li>git diff HEAD HEAD^ – login.py //对比两个版本间某个文件修改</li></ul><h3 id="git-远程仓库-pull-和-push"><a href="#git-远程仓库-pull-和-push" class="headerlink" title="git 远程仓库 pull 和 push"></a>git 远程仓库 pull 和 push</h3><ul><li>首先需要在远程仓库创建一个项目</li><li>git clone 仓库地址 // 克隆远程服务器的代码</li><li>git push origin branch // 推送本地仓库的代码到远程服务器的 branch 分支</li><li>git pull origin //拉取远程 branch 分支的代码（建议在修改代码前都要拉取一下，保证自己的代码是最新的）</li></ul><h3 id="git-代码冲突"><a href="#git-代码冲突" class="headerlink" title="git 代码冲突"></a>git 代码冲突</h3><p>容易冲突的操作方式：</p><ul><li>多个人同时操作了同一个文件</li><li>一个人一直写不提交</li><li>修改之前不更新最新代码</li><li>擅自修改同事代码</li></ul><p>减少冲突的操作方式</p><ul><li>先 pull 在修改，修改完立即 commit 和 push</li><li>确保自己正在修改的文件是最新版本的</li><li>各自开发各自的模块</li></ul><p>如何解决</p><ul><li>保留需要的代码，其他与代码无关的符号全部删除。</li><li>与开发人员沟通，及时解决。</li></ul><h3 id="git-分支"><a href="#git-分支" class="headerlink" title="git 分支"></a>git 分支</h3><ul><li>git branch //查看当前的分支</li><li>git checkout -b dev //创建并且切换到分支dev</li><li>git push -u origin dev //将本地分支推送到远程</li><li>git checkout master //切换到 master</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;菜鸟都知道-Git？&quot;&gt;&lt;a href=&quot;#菜鸟都知道-Git？&quot; class=&quot;headerlink&quot; title=&quot;菜鸟都知道 Git？&quot;&gt;&lt;/a&gt;菜鸟都知道 Git？&lt;/h3&gt;&lt;p&gt;Git 是一个分布式版本管理系统，修改一次代码并提交，就会产生一个版本，这是
      
    
    </summary>
    
      <category term="Git" scheme="https://xgoteam.com/categories/Git/"/>
    
    
      <category term="Git" scheme="https://xgoteam.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes网络原理及方案</title>
    <link href="https://xgoteam.com/2019/03/31/Kubernetes%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E6%96%B9%E6%A1%88/"/>
    <id>https://xgoteam.com/2019/03/31/Kubernetes网络原理及方案/</id>
    <published>2019-03-31T17:18:19.000Z</published>
    <updated>2019-04-17T02:58:55.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kubernetes网络模型"><a href="#Kubernetes网络模型" class="headerlink" title="Kubernetes网络模型"></a>Kubernetes网络模型</h2><p>在Kubernetes网络中存在两种IP（Pod IP和Service Cluster IP），Pod IP 地址是实际存在于某个网卡(可以是虚拟设备)上的，Service Cluster IP它是一个虚拟IP，是由kube-proxy使用Iptables规则重新定向到其本地端口，再均衡到后端Pod的。下面讲讲Kubernetes Pod网络设计模型：</p><p><strong>1、基本原则：</strong></p><p>每个Pod都拥有一个独立的IP地址（IPper Pod），而且假定所有的pod都在一个可以直接连通的、扁平的网络空间中。</p><p><strong>2、设计原因：</strong></p><p>用户不需要额外考虑如何建立Pod之间的连接，也不需要考虑将容器端口映射到主机端口等问题。</p><p><strong>3、网络要求：</strong></p><p>所有的容器都可以在不用NAT的方式下同别的容器通讯；所有节点都可在不用NAT的方式下同所有容器通讯；容器的地址和别人看到的地址是同一个地址。</p><h2 id="Docker网络基础"><a href="#Docker网络基础" class="headerlink" title="Docker网络基础"></a>Docker网络基础</h2><ul><li><strong>Linux网络名词解释：</strong></li></ul><p><strong>1、网络的命名空间：</strong>Linux在网络栈中引入网络命名空间，将独立的网络协议栈隔离到不同的命令空间中，彼此间无法通信；docker利用这一特性，实现不容器间的网络隔离。</p><p><strong>2、Veth设备对：</strong>Veth设备对的引入是为了实现在不同网络命名空间的通信。</p><p><strong>3、Iptables/Netfilter：</strong>Netfilter负责在内核中执行各种挂接的规则(过滤、修改、丢弃等)，运行在内核 模式中；Iptables模式是在用户模式下运行的进程，负责协助维护内核中Netfilter的各种规则表；通过二者的配合来实现整个Linux网络协议栈中灵活的数据包处理机制。</p><p><strong>4、网桥：</strong>网桥是一个二层网络设备,通过网桥可以将linux支持的不同的端口连接起来,并实现类似交换机那样的多对多的通信。</p><p><strong>5、路由：</strong>Linux系统包含一个完整的路由功能，当IP层在处理数据发送或转发的时候，会使用路由表来决定发往哪里。</p><ul><li><strong>Docker生态技术栈</strong></li></ul><p>下图展示了Docker网络在整个Docker生态技术栈中的位置：</p><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205252.jpg" alt="20170526205252"></p><ul><li><strong>Docker网络实现</strong></li></ul><p><strong>1、单机**</strong>网络模式：**Bridge 、Host、Container、None，这里具体就不赘述了。</p><p><strong>2、多机网络模**</strong>式：**一类是 Docker 在 1.9 版本中引入Libnetwork项目，对跨节点网络的原生支持；一类是通过插件（plugin）方式引入的第三方实现方案，比如 Flannel，Calico 等等。</p><h2 id="Kubernetes网络基础"><a href="#Kubernetes网络基础" class="headerlink" title="Kubernetes网络基础"></a>Kubernetes网络基础</h2><p><strong>1、容器间通信：</strong></p><p>同一个<a href="https://www.kubernetes.org.cn/tags/pod" target="_blank" rel="noopener">Pod</a>的容器共享同一个网络命名空间，它们之间的访问可以用localhost地址 + 容器端口就可以访问。</p><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205259.jpg" alt="20170526205259"></p><p><strong>2、同一Node中Pod间通信：</strong></p><p>同一Node中Pod的默认路由都是docker0的地址，由于它们关联在同一个docker0网桥上，地址网段相同，所有它们之间应当是能直接通信的。</p><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205307.jpg" alt="20170526205307"></p><p><strong>3、不同Node中Pod间通信：</strong></p><p>不同Node中Pod间通信要满足2个条件： Pod的IP不能冲突； 将Pod的IP和所在的Node的IP关联起来，通过这个关联让Pod可以互相访问。</p><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205316.jpg" alt="20170526205316"></p><p><strong>4、Service介绍：</strong></p><p>Service是一组Pod的服务抽象，相当于一组Pod的LB，负责将请求分发给对应的</p><p>Pod；Service会为这个LB提供一个IP，一般称为ClusterIP。</p><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205331.jpg" alt="20170526205331"></p><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205339.jpg" alt="20170526205339"></p><p><strong>5、Kube-proxy介绍：</strong></p><p>Kube-proxy是一个简单的网络代理和负载均衡器，它的作用主要是负责Service的实现，具体来说，就是实现了内部从Pod到Service和外部的从NodePort向Service的访问。</p><p><strong>实现方式：</strong></p><ul><li><p>userspace是在用户空间，通过kuber-proxy实现LB的代理服务，这个是kube-proxy的最初的版本，较为稳定，但是效率也自然不太高。</p></li><li><p>iptables是纯采用iptables来实现LB，是目前kube-proxy默认的方式。</p></li></ul><p><strong>下面是iptables模式下Kube-proxy的实现方式：</strong></p><p><strong><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205348.jpg" alt="20170526205348"></strong></p><ul><li><p>在这种模式下，kube-proxy监视Kubernetes主服务器添加和删除服务和端点对象。对于每个服务，它安装iptables规则，捕获到服务的clusterIP（虚拟）和端口的流量，并将流量重定向到服务的后端集合之一。对于每个Endpoints对象，它安装选择后端Pod的iptables规则。</p></li><li><p>默认情况下，后端的选择是随机的。可以通过将service.spec.sessionAffinity设置为“ClientIP”（默认为“无”）来选择基于客户端IP的会话关联。</p></li><li><p>与用户空间代理一样，最终结果是绑定到服务的IP:端口的任何流量被代理到适当的后端，而客户端不知道关于Kubernetes或服务或Pod的任何信息。这应该比用户空间代理更快，更可靠。然而，与用户空间代理不同，如果最初选择的Pod不响应，则iptables代理不能自动重试另一个Pod，因此它取决于具有工作准备就绪探测。</p></li></ul><p><strong>6、Kube-dns介绍</strong></p><p>Kube-dns用来为kubernetes service分配子域名，在集群中可以通过名称访问service；通常kube-dns会为service赋予一个名为“service名称.namespace.svc.cluster.local”的A记录，用来解析service的clusterip。</p><p><strong>Kube-dns组件：</strong></p><ul><li><p>在Kubernetes v1.4版本之前由“Kube2sky、Etcd、Skydns、Exechealthz”四个组件组成。</p></li><li><p>在Kubernetes v1.4版本及之后由“Kubedns、dnsmasq、exechealthz”三个组件组成。</p></li></ul><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205356.jpg" alt="20170526205356"></p><p><strong> Kubedns</strong></p><ul><li>接入SkyDNS，为dnsmasq提供查询服务。</li><li>替换etcd容器，使用树形结构在内存中保存DNS记录。</li><li>通过K8S API监视Service资源变化并更新DNS记录。</li><li>服务10053端口。</li></ul><p><strong>Dnsmasq</strong></p><ul><li><p>Dnsmasq是一款小巧的DNS配置工具。</p></li><li><p>在kube-dns插件中的作用是：</p></li></ul><ol><li>通过kubedns容器获取DNS规则，在集群中提供DNS查询服务</li><li>提供DNS缓存，提高查询性能</li><li>降低kubedns容器的压力、提高稳定性</li></ol><ul><li><p>Dockerfile在GitHub上Kubernetes组织的contrib仓库中，位于dnsmasq目录下。</p></li><li><p>在kube-dns插件的编排文件中可以看到，dnsmasq通过参数–server=127.0.0.1:10053指定upstream为kubedns。</p></li></ul><p><strong>Exechealthz</strong></p><ul><li>在kube-dns插件中提供健康检查功能。</li><li>源码同样在contrib仓库中，位于exec-healthz目录下。</li><li>新版中会对两个容器都进行健康检查，更加完善。</li></ul><h2 id="Kubernetes网络开源组件"><a href="#Kubernetes网络开源组件" class="headerlink" title="Kubernetes网络开源组件"></a>Kubernetes网络开源组件</h2><p><strong>1、技术术语：</strong></p><p><strong>IPAM：</strong>IP地址管理；这个IP地址管理并不是容器所特有的，传统的网络比如说DHCP其实也是一种IPAM，到了容器时代我们谈IPAM，主流的两种方法： 基于CIDR的IP地址段分配地或者精确为每一个容器分配IP。但总之一旦形成一个容器主机集群之后，上面的容器都要给它分配一个全局唯一的IP地址，这就涉及到IPAM的话题。</p><p><strong>Overlay：</strong>在现有二层或三层网络之上再构建起来一个独立的网络，这个网络通常会有自己独立的IP地址空间、交换或者路由的实现。</p><p><strong>IPSesc：</strong>一个点对点的一个加密通信协议，一般会用到Overlay网络的数据通道里。</p><p><strong>vxLAN：</strong>由VMware、Cisco、RedHat等联合提出的这么一个解决方案，这个解决方案最主要是解决VLAN支持虚拟网络数量（4096）过少的问题。因为在公有云上每一个租户都有不同的VPC，4096明显不够用。就有了vxLAN，它可以支持1600万个虚拟网络，基本上公有云是够用的。</p><p><strong>网桥Bridge： </strong>连接两个对等网络之间的网络设备，但在今天的语境里指的是Linux Bridge，就是大名鼎鼎的Docker0这个网桥。</p><p><strong>BGP：</strong> 主干网自治网络的路由协议，今天有了互联网，互联网由很多小的自治网络构成的，自治网络之间的三层路由是由BGP实现的。</p><p><strong>SDN、Openflow：</strong> 软件定义网络里面的一个术语，比如说我们经常听到的流表、控制平面，或者转发平面都是Openflow里的术语。</p><p><strong>2、容器网络方案：</strong></p><p><strong>隧道方案（ Overlay Networking ）</strong></p><p>隧道方案在IaaS层的网络中应用也比较多，大家共识是随着节点规模的增长复杂度会提升，而且出了网络问题跟踪起来比较麻烦，大规模集群情况下这是需要考虑的一个点。</p><ul><li><strong>Weave：</strong>UDP广播，本机建立新的BR，通过PCAP互通</li><li><strong>Open vSwitch（OVS）：</strong>基于VxLan和GRE协议，但是性能方面损失比较严重</li><li><strong>Flannel：</strong>UDP广播，VxLan</li><li><strong>Racher：</strong>IPsec</li></ul><p><strong>路由方案</strong></p><p>路由方案一般是从3层或者2层实现隔离和跨主机容器互通的，出了问题也很容易排查。</p><ul><li><strong>Calico：</strong>基于BGP协议的路由方案，支持很细致的ACL控制，对混合云亲和度比较高。</li><li><strong>Macvlan：</strong>从逻辑和Kernel层来看隔离性和性能最优的方案，基于二层隔离，所以需要二层路由器支持，大多数云服务商不支持，所以混合云上比较难以实现。</li></ul><p><strong>3、CNM &amp; CNI阵营：</strong></p><p>容器网络发展到现在，形成了两大阵营，就是Docker的CNM和Google、CoreOS、Kuberenetes主导的CNI。首先明确一点，CNM和CNI并不是网络实现，他们是网络规范和网络体系，从研发的角度他们就是一堆接口，你底层是用Flannel也好、用Calico也好，他们并不关心，CNM和CNI关心的是网络管理的问题。</p><p><strong>CNM（Docker LibnetworkContainer Network Model）:</strong></p><p>Docker Libnetwork的优势就是原生，而且和Docker容器生命周期结合紧密；缺点也可以理解为是原生，被Docker“绑架”。</p><ul><li>Docker Swarm overlay</li><li>Macvlan &amp; IP networkdrivers</li><li>Calico</li><li>Contiv</li><li>Weave</li></ul><p><strong>CNI（Container NetworkInterface）：</strong></p><p>CNI的优势是兼容其他容器技术（e.g. rkt）及上层编排系统（Kubernetes &amp; Mesos)，而且社区活跃势头迅猛，Kubernetes加上CoreOS主推；缺点是非Docker原生。</p><ul><li>Kubernetes</li><li>Weave</li><li>Macvlan</li><li>Calico</li><li>Flannel</li><li>Contiv</li><li>Mesos CNI</li></ul><p><strong>4**</strong>、Flannel容器网络：**</p><p>Flannel之所以可以搭建kubernets依赖的底层网络，是因为它可以实现以下两点：</p><ul><li>它给每个node上的docker容器分配相互不想冲突的IP地址；</li><li>它能给这些IP地址之间建立一个覆盖网络，同过覆盖网络，将数据包原封不动的传递到目标容器内。</li></ul><p><strong>Flannel介绍</strong></p><ul><li>Flannel是CoreOS团队针对Kubernetes设计的一个网络规划服务，简单来说，它的功能是让集群中的不同节点主机创建的Docker容器都具有全集群唯一的虚拟IP地址。</li><li>在默认的Docker配置中，每个节点上的Docker服务会分别负责所在节点容器的IP分配。这样导致的一个问题是，不同节点上容器可能获得相同的内外IP地址。并使这些容器之间能够之间通过IP地址相互找到，也就是相互ping通。</li><li>Flannel的设计目的就是为集群中的所有节点重新规划IP地址的使用规则，从而使得不同节点上的容器能够获得“同属一个内网”且”不重复的”IP地址，并让属于不同节点上的容器能够直接通过内网IP通信。</li><li>Flannel实质上是一种“覆盖网络(overlaynetwork)”，也就是将TCP数据包装在另一种网络包里面进行路由转发和通信，目前已经支持udp、vxlan、host-gw、aws-vpc、gce和alloc路由等数据转发方式，默认的节点间数据通信方式是UDP转发。</li></ul><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205407.jpg" alt="20170526205407"></p><p><strong>5、Calico容器网络：</strong></p><p><strong>Calico介绍</strong></p><ul><li>Calico是一个纯3层的数据中心网络方案，而且无缝集成像OpenStack这种IaaS云架构，能够提供可控的VM、容器、裸机之间的IP通信。Calico不使用重叠网络比如flannel和libnetwork重叠网络驱动，它是一个纯三层的方法，使用虚拟路由代替虚拟交换，每一台虚拟路由通过BGP协议传播可达信息（路由）到剩余数据中心。</li><li>Calico在每一个计算节点利用Linux Kernel实现了一个高效的vRouter来负责数据转发，而每个vRouter通过BGP协议负责把自己上运行的workload的路由信息像整个Calico网络内传播——小规模部署可以直接互联，大规模下可通过指定的BGP route reflector来完成。</li><li>Calico节点组网可以直接利用数据中心的网络结构（无论是L2或者L3），不需要额外的NAT，隧道或者Overlay Network。</li><li>Calico基于iptables还提供了丰富而灵活的网络Policy，保证通过各个节点上的ACLs来提供Workload的多租户隔离、安全组以及其他可达性限制等功能。</li></ul><p><strong>Calico架构图</strong></p><p><strong><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205416.jpg" alt="20170526205416"></strong></p><h2 id="网络开源组件性能对比分析"><a href="#网络开源组件性能对比分析" class="headerlink" title="网络开源组件性能对比分析"></a>网络开源组件性能对比分析</h2><p><strong>性能对比分析：</strong></p><p><strong><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205425.jpg" alt="20170526205425"></strong></p><p><strong>性能对比总结：</strong></p><p>CalicoBGP 方案最好，不能用 BGP 也可以考虑 Calico ipip tunnel 方案；如果是 Coreos 系又能开 udp offload，flannel 是不错的选择；Docker 原生Overlay还有很多需要改进的地方。</p><p><img src="https://www.kubernetes.org.cn/img/2017/05/20170526205431.jpg" alt="20170526205431"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kubernetes网络模型&quot;&gt;&lt;a href=&quot;#Kubernetes网络模型&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes网络模型&quot;&gt;&lt;/a&gt;Kubernetes网络模型&lt;/h2&gt;&lt;p&gt;在Kubernetes网络中存在两种IP（P
      
    
    </summary>
    
      <category term="容器" scheme="https://xgoteam.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="集群管理" scheme="https://xgoteam.com/categories/%E5%AE%B9%E5%99%A8/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="虚拟化" scheme="https://xgoteam.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="https://xgoteam.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Kubernetes" scheme="https://xgoteam.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Docker 中国官方镜像加速</title>
    <link href="https://xgoteam.com/2019/03/31/Docker%E4%B8%AD%E5%9B%BD%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/"/>
    <id>https://xgoteam.com/2019/03/31/Docker中国官方镜像加速/</id>
    <published>2019-03-31T15:29:20.000Z</published>
    <updated>2019-04-17T02:58:55.395Z</updated>
    
    <content type="html"><![CDATA[<p>通过 Docker 官方镜像加速，中国区用户能够快速访问最流行的 Docker 镜像。该镜像托管于中国大陆，本地用户现在将会享受到更快的下载速度和更强的稳定性，从而能够更敏捷地开发和交付 Docker 化应用。</p><p>Docker 中国官方镜像加速可通过 registry.docker-cn.com 访问。该镜像库只包含流行的公有镜像。私有镜像仍需要从美国镜像库中拉取。</p><p>您可以使用以下命令直接从该镜像加速地址进行拉取：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull registry<span class="selector-class">.docker-cn</span><span class="selector-class">.com</span>/myname/myrepo:mytag</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull registry<span class="selector-class">.docker-cn</span><span class="selector-class">.com</span>/library/ubuntu:<span class="number">16.04</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注</strong>: 除非您修改了 Docker 守护进程的 <code>`--registry-mirror`</code> 参数 (见下文), 否则您将需要完整地指定官方镜像的名称。例如，library/ubuntu、library/redis、library/nginx。</p></blockquote><h4 id="使用-registry-mirror-配置-Docker-守护进程"><a href="#使用-registry-mirror-配置-Docker-守护进程" class="headerlink" title="使用 --registry-mirror 配置 Docker 守护进程"></a>使用 --registry-mirror 配置 Docker 守护进程</h4><p>您可以配置 Docker 守护进程默认使用 Docker 官方镜像加速。这样您可以默认通过官方镜像加速拉取镜像，而无需在每次拉取时指定 registry.docker-cn.com。</p><p>您可以在 Docker 守护进程启动时传入 <code>--registry-mirror</code> 参数：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker --registry-mirror=http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span> daemon</span><br></pre></td></tr></table></figure><p>为了永久性保留更改，您可以修改 <code>/etc/docker/daemon.json</code> 文件并添加上 registry-mirrors 键值。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]&#125;</span><br></pre></td></tr></table></figure><p>修改保存后重启 Docker 以使配置生效。</p><blockquote><p><strong>注</strong>: 您也可以使用适用于 Mac 的 Docker 和适用于 Windows 的 Docker 来进行设置。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过 Docker 官方镜像加速，中国区用户能够快速访问最流行的 Docker 镜像。该镜像托管于中国大陆，本地用户现在将会享受到更快的下载速度和更强的稳定性，从而能够更敏捷地开发和交付 Docker 化应用。&lt;/p&gt;
&lt;p&gt;Docker 中国官方镜像加速可通过 regis
      
    
    </summary>
    
      <category term="容器" scheme="https://xgoteam.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="虚拟化" scheme="https://xgoteam.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="https://xgoteam.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="https://xgoteam.com/2019/03/31/Docker%E5%85%A5%E9%97%A8/"/>
    <id>https://xgoteam.com/2019/03/31/Docker入门/</id>
    <published>2019-03-31T15:29:20.000Z</published>
    <updated>2019-04-17T02:58:55.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h1><p>Docker 起初是 dotCloud 公司创始人 Solomon Hykes 在法国的时候发起的一项公司内部项目，Docker是基于 dotCloud 公司多年云服务技术的一次革新，在 2013 年 3 月以 Apache 2.0 授权协议进行开源，其项目主要代码在 GitHub 上进行维护，自从Docker 开源之后，就一直受到了广泛讨论和关注。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584c8b4d7dc120?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>Docker 进行开发实现使用的是Google 公司推出的 Go 语言，对进程进行封装隔离是基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，这属于操作系统层面的虚拟化技术。因为隔离的进程独立于宿主与其它隔离的进程，所以也称其为容器（后文会对“容器”的概念进行详细介绍）。Docker 在容器的基础上，进行了进一步的封装，从网络互联、文件系统到进程隔离等，大大地简化了容器的创建和维护，让 Docker 技术比虚拟机技术更加轻便、快捷。</p><p>以下两张图片对比了 Docker 与传统虚拟化方式的不同之处。Docker 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，没有进行硬件虚拟；而传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。因此容器要比传统虚拟机更为轻便。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584c95d9cc4367?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><em>传统虚拟化</em></p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584c994af8544e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p><em>Docker</em></p><h1 id="为什么要使用-Docker？"><a href="#为什么要使用-Docker？" class="headerlink" title="为什么要使用 Docker？"></a>为什么要使用 Docker？</h1><p>Docker是一种新兴的虚拟化方式，跟传统的虚拟化方式相比具有众多优势。</p><h2 id="系统资源利用更高效"><a href="#系统资源利用更高效" class="headerlink" title="系统资源利用更高效"></a>系统资源利用更高效</h2><p>因为容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，所以Docker 对系统资源的利用率更高。</p><h2 id="启动时间更快速"><a href="#启动时间更快速" class="headerlink" title="启动时间更快速"></a>启动时间更快速</h2><p>Docker 容器应用由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。极大地节省了开发、测试，部署的时间。</p><h2 id="运行环境一致性"><a href="#运行环境一致性" class="headerlink" title="运行环境一致性"></a>运行环境一致性</h2><p>开发过程中比较常见的问题就是环境一致性问题。因为开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p><h2 id="持续交付与部署"><a href="#持续交付与部署" class="headerlink" title="持续交付与部署"></a>持续交付与部署</h2><p>对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合持续集成(Continuous Integration)系统进行集成测试，而运维人员则可以直接在各种环境中快速部署该镜像，甚至结合持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p><p>而且使用 Dockerfile 使镜像构建透明化，不仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好地在生产环境中部署该镜像。</p><h2 id="迁移更轻松"><a href="#迁移更轻松" class="headerlink" title="迁移更轻松"></a>迁移更轻松</h2><p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻松地将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境变化导致应用无法正常运行的情况。</p><h2 id="维护和扩展更轻松"><a href="#维护和扩展更轻松" class="headerlink" title="维护和扩展更轻松"></a>维护和扩展更轻松</h2><p>Docker 使用的分层存储以及镜像技术，使得应用重复部分的复用更为容易，也使得应用的维护更新和基于基础镜像进一步扩展镜像变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大降低了应用服务的镜像制作成本。</p><h1 id="Docker的镜像和容器"><a href="#Docker的镜像和容器" class="headerlink" title="Docker的镜像和容器"></a>Docker的镜像和容器</h1><p>Docker的口号是“Build, Ship and Run Any App, Anywhere.”，大意是编译好一个应用后，可以在任何地方运行，不会像传统的程序一样，一旦换了运行环境，往往就会出现缺这个库，少那个包的问题。那么Docker是怎么做到这点的呢？</p><p>简单说就是它在编译应用的时候把这个应用依赖的所有东西都构建到镜像里面（有点像程序的静态编译——只是像而已）。我们把这个编译构建好的东西叫Docker镜像（Image），然后当Docker deamon（Docker的守护进程/服务进程）运行这个镜像的时候，我们称其为Docker容器（Container）。可以简单理解Docker镜像和Docker容器的关系就像是程序和进程的关系一样(当然实质是不一样的)。</p><h2 id="Images和Layers"><a href="#Images和Layers" class="headerlink" title="Images和Layers"></a>Images和Layers</h2><p>每个Docker镜像（Image）都引用了一些只读的（read-only）层（layer），不同的文件系统layer也不同。这些layer堆叠在一起构成了容器（Container）的根文件系统（root filesystem）。下图是Ubuntu 15.04的镜像，共由4个镜像层（image layer）组成：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584ca47d6c797f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h2 id="Container和Layers"><a href="#Container和Layers" class="headerlink" title="Container和Layers"></a>Container和Layers</h2><p>容器和镜像的主要区别就是顶部的那个可写层（即之前说的那个“container layer”）。容器运行时做的所有操作都会写到这个可写层里面，当容器删除的时候，这个可写层也会被删掉，但底层的镜像依旧保持不变。所以，不同的容器都有自己的可写层，但可以共享同一个底层镜像。下图展示了多个容器共享同一个Ubuntu 15.04镜像。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584cab0e859909?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>Docker的storage driver负责管理只读的镜像层和可写的容器层，当然不同的driver实现的方式也不同，但其后都有两项关键技术：<strong>可堆叠的镜像层</strong>（stackable image layer）和<strong>写时拷贝技术</strong>（copy-on-write, CoW）。</p><h2 id="Docker数据持久化"><a href="#Docker数据持久化" class="headerlink" title="Docker数据持久化"></a>Docker数据持久化</h2><p>刚开始的时候，Docker一般只适用于无状态的计算场景使用。但随着发展，Docker通过data volume技术也可以做到数据持久化了。Data volume就是我们将主机的某个目录挂载到容器里面，这个data volume不受storage driver的控制，所有对这个data volume的操作会绕过storage driver直接其操作，其性能也只受本地主机的限制。而且我们可以挂载任意多个data volume到容器中，不同容器也可以共享同一个data volume。</p><p>下图展示了一个Docker主机上面运行着两个容器.每一个容器在主机上面都有着自己的地址空间（/var/lib/docker/…），除此以外，它们还共享着主机上面的同一个/data目录。</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584cb3b1967b51?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>参考文档：</p><p><a href="https://link.juejin.im?target=https%3A%2F%2Fyeasy.gitbooks.io%2Fdocker_practice%2Fcontent%2Fintroduction%2Fwhat.html" target="_blank" rel="noopener">yeasy.gitbooks.io/docker_prac…</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fyeasy.gitbooks.io%2Fdocker_practice%2Fcontent%2Fintroduction%2Fwhy.html" target="_blank" rel="noopener">yeasy.gitbooks.io/docker_prac…</a> <a href="https://link.juejin.im?target=https%3A%2F%2Fdocs.docker.com%2Fstorage%2Fstoragedriver%2F" target="_blank" rel="noopener">docs.docker.com/storage/sto…</a></p><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p><p>Docker CE 的安装请参考官方文档。</p><ul><li><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">Mac</a></li><li><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Windows</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Ubuntu</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">Debian</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">CentOS</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/fedora/" target="_blank" rel="noopener">Fedora</a></li><li><a href="https://docs.docker.com/install/linux/docker-ce/binaries/" target="_blank" rel="noopener">其他 Linux 发行版</a></li></ul><p>安装完成后，运行下面的命令，验证是否安装成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker version</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker info</span><br></pre></td></tr></table></figure><p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（<a href="https://docs.docker.com/install/linux/linux-postinstall/#manage-docker-as-a-non-root-user" target="_blank" rel="noopener">官方文档</a>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>Docker 是服务器----客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（<a href="https://docs.docker.com/config/daemon/systemd/" target="_blank" rel="noopener">官方文档</a>）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service 命令的用法</span></span><br><span class="line">$ sudo service docker start</span><br><span class="line"><span class="comment"># systemctl 命令的用法</span></span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><h1 id="image-文件"><a href="#image-文件" class="headerlink" title="image 文件"></a>image 文件</h1><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机的所有 image 文件。</span></span><br><span class="line">$ docker image ls</span><br><span class="line"><span class="comment"># 删除 image 文件</span></span><br><span class="line">$ docker image rm [imageName]</span><br></pre></td></tr></table></figure><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p><h1 id="实例：hello-world"><a href="#实例：hello-world" class="headerlink" title="实例：hello world"></a>实例：hello world</h1><p>下面，我们通过最简单的 image 文件”<a href="https://hub.docker.com/r/library/hello-world/" target="_blank" rel="noopener">hello world”</a>，感受一下 Docker。</p><p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法</p><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull library/hello-world</span><br></pre></td></tr></table></figure><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href="https://hub.docker.com/r/library/" target="_blank" rel="noopener"><code>library</code></a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image pull hello-world</span><br></pre></td></tr></table></figure><p>抓取成功以后，就可以在本机看到这个 image 文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure><p>现在，运行这个 image 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker container run hello-world</span><br></pre></td></tr></table></figure><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><p>如果运行成功，你会在屏幕上读到下面的输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run hello-world</span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -it ubuntu bash</span><br></pre></td></tr></table></figure><p>对于那些不会自动终止的容器，必须使用<a href="https://docs.docker.com/engine/reference/commandline/container_kill/" target="_blank" rel="noopener"><code>docker container kill</code></a> 命令手动终止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container <span class="built_in">kill</span> [containID]</span><br></pre></td></tr></table></figure><h1 id="容器文件"><a href="#容器文件" class="headerlink" title="容器文件"></a>容器文件</h1><p><strong> image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本机正在运行的容器</span></span><br><span class="line">$ docker container ls</span><br><span class="line"><span class="comment"># 列出本机所有容器，包括终止运行的容器</span></span><br><span class="line">$ docker container ls --all</span><br></pre></td></tr></table></figure><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<a href="https://docs.docker.com/engine/reference/commandline/container_rm/" target="_blank" rel="noopener"><code>docker container rm</code></a>命令删除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h1 id="Dockerfile-文件"><a href="#Dockerfile-文件" class="headerlink" title="Dockerfile 文件"></a>Dockerfile 文件</h1><p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p><p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p><p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p><h1 id="实例：制作自己的-Docker-容器"><a href="#实例：制作自己的-Docker-容器" class="headerlink" title="实例：制作自己的 Docker 容器"></a>实例：制作自己的 Docker 容器</h1><p>下面我以 <a href="http://www.ruanyifeng.com/blog/2017/08/koa.html" target="_blank" rel="noopener">koa-demos</a> 项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p><p>作为准备工作，请先<a href="https://github.com/ruanyf/koa-demos/archive/master.zip" target="_blank" rel="noopener">下载源码</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/ruanyf/koa-demos.git</span><br><span class="line">$ <span class="built_in">cd</span> koa-demos</span><br></pre></td></tr></table></figure><h2 id="编写-Dockerfile-文件"><a href="#编写-Dockerfile-文件" class="headerlink" title="编写 Dockerfile 文件"></a>编写 Dockerfile 文件</h2><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/.dockerignore" target="_blank" rel="noopener">内容</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的<a href="https://github.com/ruanyf/koa-demos/blob/master/Dockerfile" target="_blank" rel="noopener">内容</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br></pre></td></tr></table></figure><p>上面代码一共五行，含义如下。</p><ul><li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li><li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li><li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li><li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li><li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li></ul><h2 id="创建-image-文件"><a href="#创建-image-文件" class="headerlink" title="创建 image 文件"></a>创建 image 文件</h2><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t koa-demo .</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker image build -t koa-demo:0.0.1 .</span><br></pre></td></tr></table></figure><p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p><p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br></pre></td></tr></table></figure><h2 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h2><p><code>docker container run</code>命令会从 image 文件生成容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run -p 8000:3000 -it koa-demo /bin/bash</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash</span><br></pre></td></tr></table></figure><p>上面命令的各个参数含义如下：</p><ul><li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li><li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li><li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li><li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li></ul><p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@66d80f4aaf1e:/app<span class="comment"># node demos/01.js</span></span><br></pre></td></tr></table></figure><p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 <a href="http://127.0.0.1:8000，网页显示&quot;Not" target="_blank" rel="noopener">http://127.0.0.1:8000，网页显示&quot;Not</a> Found”，这是因为这个 <a href="https://github.com/ruanyf/koa-demos/blob/master/demos/01.js" target="_blank" rel="noopener">demo</a> 没有写路由。</p><p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p><p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在本机的另一个终端窗口，查出容器的 ID</span></span><br><span class="line">$ docker container ls</span><br><span class="line"><span class="comment"># 停止指定的容器运行</span></span><br><span class="line">$ docker container <span class="built_in">kill</span> [containerID]</span><br></pre></td></tr></table></figure><p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查出容器的 ID</span></span><br><span class="line">$ docker container ls --all</span><br><span class="line"><span class="comment"># 删除指定的容器文件</span></span><br><span class="line">$ docker container rm [containerID]</span><br></pre></td></tr></table></figure><p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash</span><br></pre></td></tr></table></figure><h2 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h2><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM node:8.4</span><br><span class="line">COPY . /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">RUN npm install --registry=https://registry.npm.taobao.org</span><br><span class="line">EXPOSE 3000</span><br><span class="line">CMD node demos/01.js</span><br></pre></td></tr></table></figure><p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1</span><br></pre></td></tr></table></figure><h2 id="发布-image-文件"><a href="#发布-image-文件" class="headerlink" title="发布 image 文件"></a>发布 image 文件</h2><p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p><p>首先，去 <a href="https://hub.docker.com/" target="_blank" rel="noopener">hub.docker.com</a> 或 <a href="https://cloud.docker.com" target="_blank" rel="noopener">cloud.docker.com</a> 注册一个账户。然后，用下面的命令登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>接着，为本地的 image 标注用户名和版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker image tag [imageName] [username]/[repository]:[tag]</span><br><span class="line"><span class="comment"># 实例</span></span><br><span class="line">$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1</span><br></pre></td></tr></table></figure><p>也可以不标注用户名，重新构建一下 image 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build -t [username]/[repository]:[tag] .</span><br></pre></td></tr></table></figure><p>最后，发布 image 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker image push [username]/[repository]:[tag]</span><br></pre></td></tr></table></figure><p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p><h2 id="其他有用的命令"><a href="#其他有用的命令" class="headerlink" title="其他有用的命令"></a>其他有用的命令</h2><p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p><p><strong>（1）docker container start</strong></p><p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;</span><br><span class="line">$ docker container start [containerID]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p><strong>（2）docker container stop</strong></p><p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ bash container stop [containerID]</span><br></pre></td></tr></table></figure><p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p><p><strong>（3）docker container logs</strong></p><p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker container logs [containerID]</span><br></pre></td></tr></table></figure><p><strong>（4）docker container exec</strong></p><p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker container <span class="built_in">exec</span> -it [containerID] /bin/bash</span><br></pre></td></tr></table></figure><p><strong>（5）docker container cp</strong></p><p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ docker container cp [containID]:[/path/to/file] .</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker是什么&quot;&gt;&lt;a href=&quot;#Docker是什么&quot; class=&quot;headerlink&quot; title=&quot;Docker是什么&quot;&gt;&lt;/a&gt;Docker是什么&lt;/h1&gt;&lt;p&gt;Docker 起初是 dotCloud 公司创始人 Solomon Hykes 在法
      
    
    </summary>
    
      <category term="容器" scheme="https://xgoteam.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="虚拟化" scheme="https://xgoteam.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="https://xgoteam.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes入门</title>
    <link href="https://xgoteam.com/2019/03/31/Kubernetes%E5%85%A5%E9%97%A8/"/>
    <id>https://xgoteam.com/2019/03/31/Kubernetes入门/</id>
    <published>2019-03-31T09:51:53.000Z</published>
    <updated>2019-04-17T02:58:55.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-简介"><a href="#Kubernetes-简介" class="headerlink" title="Kubernetes 简介"></a>Kubernetes 简介</h1><p>Kubernetes，又称为 k8s（首字母为 k、首字母与尾字母之间有 8 个字符、尾字母为 s，所以简称 k8s）或者简称为 “kube” ，是一种可自动实施 Linux 容器操作的开源平台。它可以帮助用户省去应用容器化过程的许多手动部署和扩展操作。也就是说，您可以将运行 Linux 容器的多组主机聚集在一起，由 Kubernetes 帮助您轻松高效地管理这些集群。而且，这些集群可跨公共云、私有云或混合云部署主机。因此，对于要求快速扩展的云原生应用而言（例如借助 Apache Kafka 进行的实时数据流处理），Kubernetes 是理想的托管平台。</p><p>Kubernetes 最初由 Google 的工程师开发和设计。Google 是最早研发 Linux 容器技术的企业之一，曾公开分享介绍 Google 如何将一切都运行于容器之中（这是 Google 云服务背后的技术）。Google 每周会启用超过 20 亿个容器——全都由内部平台 Borg 支撑。Borg 是 Kubernetes 的前身，多年来开发 Borg 的经验教训成了影响 Kubernetes 中许多技术的主要因素。</p><p>趣闻：Kubernetes 徽标的七个轮辐代表着项目最初的名称“九之七项目”（Project Seven of Nine）。</p><p>红帽是第一批与 Google 合作研发 Kubernetes 的公司之一，作为 Kubernetes 上游项目的第二大贡献者，我们甚至在这个项目启动之前就已参与其中。2015 年，Google 将 Kubernetes 项目捐赠给了新成立的云原生计算基金会。</p><p><a href="https://kubernetes.io/zh/docs/concepts/overview/what-is-kubernetes/" target="_blank" rel="noopener">认识 Kubernetes?</a></p><h2 id="您为何需要-Kubernetes？"><a href="#您为何需要-Kubernetes？" class="headerlink" title="您为何需要 Kubernetes？"></a>您为何需要 Kubernetes？</h2><p>真正的生产型应用会涉及多个容器。这些容器必须跨多个服务器主机进行部署。Kubernetes 可以提供所需的编排和管理功能，以便您针对这些工作负载大规模部署容器。借助 Kubernetes 编排功能，您可以构建跨多个容器的应用服务、跨集群调度、扩展这些容器，并长期持续管理这些容器的健康状况。</p><p>Kubernetes 还需要与联网、存储、安全性、遥测和其他服务集成整合，以提供全面的容器基础架构。</p><p><img src="https://www.redhat.com/cms/managed-files/kubernetes-diagram-902x416.png" alt="kubernetes"></p><p>当然，这取决于您如何在您的环境中使用容器。Linux 容器中的基本应用将它们视作高效、快速的虚拟机。一旦把它部署到生产环境或扩展为多个应用，您显然需要许多托管在相同位置的容器来协同提供各种服务。随着这些容器的累积，您运行环境中容器的数量会急剧增加，复杂度也随之增长。</p><p>Kubernetes 通过将容器分类组成 “容器集” （pod），解决了容器增殖带来的许多常见问题容器集为分组容器增加了一个抽象层，可帮助您调用工作负载，并为这些容器提供所需的联网和存储等服务。Kubernetes 的其它部分可帮助您在这些容器集之间达成负载平衡，同时确保运行正确数量的容器，充分支持您的工作负载。</p><p>如果能正确实施 Kubernetes，再辅以其它开源项目（例如 <a href="http://www.projectatomic.io" target="_blank" rel="noopener">Atomic 注册表</a>、<a href="http://openvswitch.org/" target="_blank" rel="noopener">Open vSwitch</a>、<a href="https://github.com/kubernetes/heapster" target="_blank" rel="noopener">heapster</a>、<a href="https://oauth.net" target="_blank" rel="noopener">OAuth</a> 以及 <a href="https://selinuxproject.org/page/Main_Page" target="_blank" rel="noopener">SELinux</a>），您就能够轻松编排容器基础架构的各个部分。</p><h2 id="Kubernetes-有哪些用途？"><a href="#Kubernetes-有哪些用途？" class="headerlink" title="Kubernetes 有哪些用途？"></a>Kubernetes 有哪些用途？</h2><p>在您生产环境中（尤其是当<a href="https://www.redhat.com/zh/topics/cloud-native-apps" target="_blank" rel="noopener">您要面向云优化应用开发时</a>）使用 Kubernetes 的主要优势在于，它提供了一个便捷有效的平台，让您可以在物理机和虚拟机集群上调度和运行容器。更广泛一点说，它可以帮助您在生产环境中，完全实施并依托基于容器的基础架构运营。由于 Kubernetes 的实质在于实现操作任务自动化，所以您可以将其它应用平台或管理系统分配给您的许多相同任务交给容器来执行。</p><p>利用 Kubernetes，您能够达成以下目标：</p><ul><li>跨多台主机进行容器编排。</li><li>更加充分地利用硬件，最大程度获取运行企业应用所需的资源。</li><li>有效管控应用部署和更新，并实现自动化操作。</li><li>挂载和增加存储，用于运行有状态的应用。</li><li>快速、按需扩展容器化应用及其资源。</li><li>对服务进行声明式管理，保证所部署的应用始终按照部署的方式运行。</li><li>利用自动布局、自动重启、自动复制以及自动扩展功能，对应用实施状况检查和自我修复。</li></ul><h2 id="学习-Kubernetes-术语"><a href="#学习-Kubernetes-术语" class="headerlink" title="学习 Kubernetes 术语"></a>学习 Kubernetes 术语</h2><p>和其它技术一样，Kubernetes 也会采用一些专用的词汇，这可能会对初学者理解和掌握这项技术造成一定的障碍。为了帮助您了解 Kubernetes，我们在下面来解释一些常用术语。</p><ul><li><p>主机（Master）<br>用于控制 Kubernetes 节点的计算机。所有任务分配都来自于此。</p></li><li><p>节点（Node）<br>负责执行请求和所分配任务的计算机。由 Kubernetes 主机负责对节点进行控制。</p></li><li><p>容器集（Pod）<br>部署在单个节点上的，且包含一个或多个容器的容器组。同一容器集中的所有容器共享同一个 IP 地址、IPC、主机名称及其它资源。容器集会将网络和存储从底层容器中抽象出来。这样，您就能更加轻松地在集群中移动容器。</p></li><li><p>复制控制器（Replication controller）<br>用于控制容器集在集群上运行的实例数量。</p></li><li><p>服务（Service）<br>将工作内容与容器集分离。Kubernetes 服务代理会自动将服务请求分发到正确的容器集——无论这个容器集会移到集群中的哪个位置，甚至可以被替换掉。</p></li><li><p>Kubelet<br>运行在节点上的服务，可读取容器清单（container manifest），确保指定的容器启动并运行。</p></li><li><p>kubectl<br>Kubernetes 的命令行配置工具。</p></li></ul><p><a href="https://kubernetes.io/docs/reference/" target="_blank" rel="noopener">想要了解更多？查看 Kubernetes 术语表。</a></p><h1 id="Kubernetes架构"><a href="#Kubernetes架构" class="headerlink" title="Kubernetes架构"></a>Kubernetes架构</h1><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>K8s设置由几个部分组成，其中一些是可选的，一些是整个系统运行所必需的。下面是k8s的全局架构图</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584ccc8cc45050?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><h2 id="master和node架构"><a href="#master和node架构" class="headerlink" title="master和node架构"></a>master和node架构</h2><p>k8s的集群组件如下：</p><p>master: apiserver,scheduler,controller-manager,etcd</p><p>node:kubelet(agent),kube-proxy,docker(container engine)</p><p>Registry:harbor，属于集群外部的</p><p>Addons(附件)：kube-dns,UI(如 dashboard)等等。在集群运行正常后，在集群上运行pod实现。</p><p><img src="https://upload-images.jianshu.io/upload_images/6943703-635819b959d1f300.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="集群环境架构"><a href="#集群环境架构" class="headerlink" title="集群环境架构"></a>集群环境架构</h2><p>注意，下图的ip可根据实际环境调整</p><p><img src="https://upload-images.jianshu.io/upload_images/6943703-3b5a09edcd957797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>Kubernetes有两个不同的部分构成，一个是Master，一个是Node。Master负责调度资源和为客户端提供API，客户端可以是UI界面或者CLI工具，在Kubernetes中CLI工具通常为kubectl。 Kubernetes Master接受使用YAML定义的配置文件，根据配置文件中相关信息将容器分配到其中一个Node上。另外，镜像库在Kubernetes中也起到一个很重要的角色，Kubernetes需要从镜像库中拉取镜像基于这个镜像的容器才能成功启动。常用的镜像库有dockerhub、阿里云镜像库等。下面图片为Master的架构图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584cd113cca3e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>Master有三个组件：API Server、Scheduler、Controller。API Server提供了友好易用的API供外部调用，同时有很多强大的工具使得API调用更加简单，如kubectl封装了大量API调用，使得部署、配置更加简单。Kubernetes-dashboard可以让用户在界面上操作Kubernetes，而无需手动输入各个API的调用地址参数等信息。</p><p>当API Server收到部署请求后，Scheduler会根据所需的资源，判断各节点的资源占用情况分配合适的Node给新的容器。判断依据包括内存、CPU、磁盘等。</p><p>Controller负责整个集群的整体协调和健康，保证每个组件以正确的方式运行。</p><p>在图的最下边是ETCD数据库。如前文所述ETCD是分布式存储数据库，其作为Kubernetes的中央数据库，存储了集群的状态，组件可以通过查询ETCD了解集群的状态。</p><p>Kubernetes Master分配容器到Node执行，Node将会承受压力，通常情况下新容器不会运行在Master上。或者说Master是不可调度的，但是你也可以选择把Master同时也作为Node,但是这并不是地道的用法。下面的为Node的架构图:</p><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584cd561b5ee60?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>Kube-proxy在Node中管理网络，其左右至关重要。Kube-proxy通过管理iptables等方式使得pod到pod之间，和pod到node之间网络能够互通。实质上在跨主机的pod之间网络也能够互通。</p><p>Kubelet负责向api server报告信息，并把健康状态、指标和节点状态信息存入ETCD中。</p><p>Supervisord保证Docker和kubelet一直在运行中，supervisord并不是必须组件，可以使用其他类似组件替换。</p><p>Pod是可以在Kubernetes中创建和管理的最小可部署计算单元。一个POD中可以包含多个容器，但Kubernetes仅管理pod。如果多个容器运行在一个POD中，就相当于这些容器运行在同一台主机中，需要注意端口占用问题。</p><p>参考资料:</p><p><a href="https://link.juejin.im?target=http%3A%2F%2Fk8s.docker8.com%2F" target="_blank" rel="noopener">k8s.docker8.com/</a><br><a href="https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DzeS6OyDoy78" target="_blank" rel="noopener">www.youtube.com/watch?v=zeS…</a></p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群是一组节点，这些节点可以是物理服务器或者虚拟机，之上安装了Kubernetes平台。下图展示这样的集群。注意该图为了强调核心概念有所简化。<a href="http://kubernetes.io/v1.1/docs/design/architecture.html" target="_blank" rel="noopener">这里</a>可以看到一个典型的Kubernetes架构图。</p><p><a href="http://dockone.io/uploads/article/20151230/d56441427680948fb56a00af57bda690.png" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20151230/d56441427680948fb56a00af57bda690.png" alt="1.png" title="1.png"></a></p><p>上图可以看到如下组件，使用特别的图标表示Service和Label：</p><ul><li>Pod</li><li>Container（容器）</li><li>Label(<img src="http://omerio.com/wp-content/uploads/2015/12/label.png" alt="label">)（标签）</li><li>Replication Controller（复制控制器）</li><li>Service（<img src="http://omerio.com/wp-content/uploads/2015/12/service.png" alt="enter image description here">）（服务）</li><li>Node（节点）</li><li>Kubernetes Master（Kubernetes主节点）</li></ul><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p><a href="http://kubernetes.io/v1.1/docs/user-guide/pods.html" target="_blank" rel="noopener">Pod</a>（上图绿色方框）安排在节点上，包含一组容器和卷。同一个Pod里的容器共享同一个网络命名空间，可以使用localhost互相通信。Pod是短暂的，不是持续性实体。你可能会有这些问题：</p><ul><li>如果Pod是短暂的，那么我怎么才能持久化容器数据使其能够跨重启而存在呢？ 是的，Kubernetes支持<a href="http://kubernetes.io/v1.1/docs/user-guide/volumes.html" target="_blank" rel="noopener">卷</a>的概念，因此可以使用持久化的卷类型。</li><li>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么？可以手动创建单个Pod，但是也可以使用Replication Controller使用Pod模板创建出多份拷贝，下文会详细介绍。</li><li>如果Pod是短暂的，那么重启时IP地址可能会改变，那么怎么才能从前端容器正确可靠地指向后台容器呢？这时可以使用Service，下文会详细介绍。</li></ul><h3 id="Lable"><a href="#Lable" class="headerlink" title="Lable"></a>Lable</h3><p>正如图所示，一些Pod有Label（<img src="http://omerio.com/wp-content/uploads/2015/12/label.png" alt="enter image description here">）。一个Label是attach到Pod的一对键/值对，用来传递用户定义的属性。比如，你可能创建了一个”tier”和“app”标签，通过Label（<strong>tier=frontend, app=myapp</strong>）来标记前端Pod容器，使用Label（<strong>tier=backend, app=myapp</strong>）标记后台Pod。然后可以使用 <a href="http://kubernetes.io/v1.1/docs/user-guide/labels.html#label-selectors" target="_blank" rel="noopener">Selectors</a>选择带有特定Label的Pod，并且将Service或者Replication Controller应用到上面。</p><h3 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h3><p><em>是否手动创建Pod，如果想要创建同一个容器的多份拷贝，需要一个个分别创建出来么，能否将Pods划到逻辑组里？</em></p><p>Replication Controller确保任意时间都有指定数量的Pod“副本”在运行。如果为某个Pod创建了Replication Controller并且指定3个副本，它会创建3个Pod，并且持续监控它们。如果某个Pod不响应，那么Replication Controller会替换它，保持总数为3.如下面的动画所示：</p><p><a href="http://dockone.io/uploads/article/20151230/5e2bad1a25e33e2d155da81da1d3a54b.gif" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20151230/5e2bad1a25e33e2d155da81da1d3a54b.gif" alt="2.gif" title="2.gif"></a></p><p>如果之前不响应的Pod恢复了，现在就有4个Pod了，那么Replication Controller会将其中一个终止保持总数为3。如果在运行中将副本总数改为5，Replication Controller会立刻启动2个新Pod，保证总数为5。还可以按照这样的方式缩小Pod，这个特性在执行滚动<a href="https://cloud.google.com/container-engine/docs/replicationcontrollers/#rolling_updates" target="_blank" rel="noopener">升级</a>时很有用。</p><p>当创建Replication Controller时，需要指定两个东西：</p><ol><li><a href="http://kubernetes.io/v1.1/docs/user-guide/replication-controller.html#pod-template" target="_blank" rel="noopener">Pod模板</a>：用来创建Pod副本的模板</li><li><a href="http://kubernetes.io/v1.1/docs/user-guide/replication-controller.html#labels" target="_blank" rel="noopener">Label</a>：Replication Controller需要监控的Pod的标签。</li></ol><p>现在已经创建了Pod的一些副本，那么在这些副本上如何均衡负载呢？我们需要的是Service。</p><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p><em>如果Pods是短暂的，那么重启时IP地址可能会改变，怎么才能从前端容器正确可靠地指向后台容器呢？</em></p><p><a href="http://kubernetes.io/v1.1/docs/user-guide/services.html" target="_blank" rel="noopener">Service</a>是定义一系列Pod以及访问这些Pod的策略的一层<strong>抽象</strong>。Service通过Label找到Pod组。因为Service是抽象的，所以在图表里通常看不到它们的存在，这也就让这一概念更难以理解。</p><p>现在，假定有2个后台Pod，并且定义后台Service的名称为‘backend-service’，lable选择器为（<strong>tier=backend, app=myapp</strong>）。<em>backend-service</em> 的Service会完成如下两件重要的事情：</p><p><em><br>    会为Service创建一个本地集群的DNS入口，因此前端Pod只需要DNS查找主机名为 ‘backend-service’，就能够解析出前端应用程序可用的IP地址。</em><br>    现在前端已经得到了后台服务的IP地址，但是它应该访问2个后台Pod的哪一个呢？Service在这2个后台Pod之间提供透明的负载均衡，会将请求分发给其中的任意一个（如下面的动画所示）。通过每个Node上运行的代理（kube-proxy）完成。<a href="http://kubernetes.io/v1.1/docs/user-guide/services.html#virtual-ips-and-service-proxies" target="_blank" rel="noopener">这里</a>有更多技术细节。</p><p>下述动画展示了Service的功能。注意该图作了很多简化。如果不进入网络配置，那么达到透明的负载均衡目标所涉及的底层网络和路由相对先进。如果有兴趣，<a href="http://www.dasblinkenlichten.com/kubernetes-101-networking/" target="_blank" rel="noopener">这里</a>有更深入的介绍。</p><p><a href="http://dockone.io/uploads/article/20151230/125bbccce0b3bbf42abab0e520d9250b.gif" target="_blank" rel="noopener"><img src="http://dockone.io/uploads/article/20151230/125bbccce0b3bbf42abab0e520d9250b.gif" alt="3.gif" title="3.gif"></a></p><p>有一个特别类型的Kubernetes Service，称为’<a href="http://kubernetes.io/v1.1/docs/user-guide/services.html#type-loadbalancer" target="_blank" rel="noopener">LoadBalancer</a>‘，作为外部负载均衡器使用，在一定数量的Pod之间均衡流量。比如，对于负载均衡Web流量很有用。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>节点（上图橘色方框）是物理或者虚拟机器，作为Kubernetes worker，通常称为Minion。每个节点都运行如下Kubernetes关键组件：</p><ul><li>Kubelet：是主节点代理。</li><li>Kube-proxy：Service使用其将链接路由到Pod，如上文所述。</li><li>Docker或Rocket：Kubernetes使用的容器技术来创建容器。</li></ul><h3 id="Kubernetes-Master"><a href="#Kubernetes-Master" class="headerlink" title="Kubernetes Master"></a>Kubernetes Master</h3><p>集群拥有一个Kubernetes Master（紫色方框）。Kubernetes Master提供集群的独特视角，并且拥有一系列组件，比如Kubernetes API Server。API Server提供可以用来和集群交互的REST端点。master节点包括用来创建和复制Pod的Replication Controller。</p><h1 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a>基础组件</h1><h2 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h2><p>Kubernetes 主要由以下几个核心组件组成：</p><ul><li>etcd：保存了整个集群的状态；</li><li>apiserver：提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；</li><li>controller manager：负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>scheduler：负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li><li>kubelet：负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；</li><li>Container runtime：负责镜像管理以及 Pod 和容器的真正运行（CRI）；</li><li>kube-proxy：负责为 Service 提供 cluster 内部的服务发现和负载均衡</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/8/29/16584cc39a95345b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt></p><p>除了核心组件，还有一些推荐的 Add-ons：</p><ul><li>kube-dns：负责为整个集群提供 DNS 服务</li><li>Ingress Controller：为服务提供外网入口</li><li>Heapster：提供资源监控</li><li>Dashboard：提供 GUI</li><li>Federation：提供跨可用区的集群</li><li>Fluentd-elasticsearch：提供集群日志采集、存储与查询</li></ul><h2 id="组件详细介绍"><a href="#组件详细介绍" class="headerlink" title="组件详细介绍"></a>组件详细介绍</h2><h3 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h3><p>Etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障（如数据库选主、分布式锁等）。</p><p>Etcd主要功能：</p><ul><li>基本的key-value存储</li><li>监听机制</li><li>key的过期及续约机制，用于监控和服务发现</li><li>原子CAS和CAD，用于分布式锁和leader选举</li></ul><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>kube-apiserver 是 Kubernetes 最重要的核心组件之一，主要提供以下的功能：</p><ul><li>提供集群管理的 REST API 接口，包括认证授权、数据校验以及集群状态变更等</li><li>提供其他模块之间的数据交互和通信的枢纽（其他模块通过 API Server 查询或修改数据，只有 API Server 才直接操作 etcd）</li></ul><h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p>Controller Manager由kube-controller-manager和cloud-controller-manager组成，是Kubernetes的大脑，它通过apiserver监控整个集群的状态，并确保集群处于预期的工作状态。</p><p>kube-controller-manager由一系列的控制器组成</p><ul><li>Replication Controller</li><li>Node Controller</li><li>CronJob Controller</li><li>Daemon Controller</li><li>Deployment Controller</li><li>Endpoint Controller</li><li>Garbage Collector</li><li>Namespace Controller</li><li>Job Controller</li><li>Pod AutoScaler</li><li>RelicaSet</li><li>Service Controller</li><li>ServiceAccount Controller</li><li>StatefulSet Controller</li><li>Volume Controller</li><li>Resource quota Controller</li></ul><h3 id="cloud-controller-manager"><a href="#cloud-controller-manager" class="headerlink" title="cloud-controller-manager"></a>cloud-controller-manager</h3><p>在Kubernetes启用Cloud Provider的时候才需要，用来配合云服务提供商的控制，也包括一系列的控制器，如：</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p>kube-scheduler 负责分配调度 Pod 到集群内的节点上，它监听 kube-apiserver，查询还未分配 Node 的 Pod，然后根据调度策略为这些 Pod 分配节点（更新 Pod的 NodeName 字段）。</p><p>调度器需要充分考虑诸多的因素：</p><ul><li>公平调度</li><li>资源高效利用</li><li>QoS</li><li>affinity 和 anti-affinity</li><li>数据本地化（data locality）</li><li>内部负载干扰（inter-workload interference）</li><li>deadlines</li></ul><h3 id="Kubelet"><a href="#Kubelet" class="headerlink" title="Kubelet"></a>Kubelet</h3><p>每个节点上都运行一个 kubelet 服务进程，默认监听 10250 端口，接收并执行 master 发来的指令，管理 Pod 及 Pod 中的容器。每个 kubelet 进程会在 API Server 上注册节点自身信息，定期向 master 节点汇报节点的资源使用情况，并通过 cAdvisor 监控节点和容器的资源。</p><h3 id="Container-runtime"><a href="#Container-runtime" class="headerlink" title="Container runtime"></a>Container runtime</h3><p>容器运行时（Container Runtime）是 Kubernetes 最重要的组件之一，负责真正管理镜像和容器的生命周期。Kubelet 通过 Container Runtime Interface (CRI) 与容器运行时交互，以管理镜像和容器。</p><h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>每台机器上都运行一个 kube-proxy 服务，它监听 API server 中 service 和 endpoint 的变化情况，并通过 iptables 等来为服务配置负载均衡（仅支持 TCP 和 UDP）。</p><p>kube-proxy 可以直接运行在物理机上，也可以以 static pod 或者 daemonset 的方式运行。</p><p>kube-proxy 当前支持一下几种实现：</p><ul><li>userspace：最早的负载均衡方案，它在用户空间监听一个端口，所有服务通过 iptables 转发到这个端口，然后在其内部负载均衡到实际的 Pod。该方式最主要的问题是效率低，有明显的性能瓶颈。</li><li>iptables：目前推荐的方案，完全以 iptables 规则的方式来实现 service 负载均衡。该方式最主要的问题是在服务多的时候产生太多的 iptables 规则，非增量式更新会引入一定的时延，大规模情况下有明显的性能问题</li><li>ipvs：为解决 iptables 模式的性能问题，v1.8 新增了 ipvs 模式，采用增量式更新，并可以保证 service 更新期间连接保持不断开</li><li>winuserspace：同 userspace，但仅工作在 windows 上。</li></ul><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p><a href="https://kubernetes.io/zh/docs/tutorials/kubernetes-basics/cluster-intro/" target="_blank" rel="noopener">使用 Minikube 创建一个集群</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Kubernetes-简介&quot;&gt;&lt;a href=&quot;#Kubernetes-简介&quot; class=&quot;headerlink&quot; title=&quot;Kubernetes 简介&quot;&gt;&lt;/a&gt;Kubernetes 简介&lt;/h1&gt;&lt;p&gt;Kubernetes，又称为 k8s（首字母为 k、
      
    
    </summary>
    
      <category term="容器" scheme="https://xgoteam.com/categories/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="集群管理" scheme="https://xgoteam.com/categories/%E5%AE%B9%E5%99%A8/%E9%9B%86%E7%BE%A4%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="虚拟化" scheme="https://xgoteam.com/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
      <category term="容器" scheme="https://xgoteam.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
      <category term="Kubernetes" scheme="https://xgoteam.com/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title>Hello world!</title>
    <link href="https://xgoteam.com/2018/04/29/hello-world/"/>
    <id>https://xgoteam.com/2018/04/29/hello-world/</id>
    <published>2018-04-29T20:29:21.000Z</published>
    <updated>2019-04-17T02:58:55.399Z</updated>
    
    <content type="html"><![CDATA[<p>Hello world!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Hello world!&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
